# Chap05. ORM

## 데이터베이스란?

- 데이터를 매우 효율적으로 보관하고 꺼내볼 수 있는 곳
- 굉장히 많은 사람이 안전하게 데이터를 사용, 관리 가능

## DBMS

- database management system
- 데이터베이스 관리 소프트웨어
- 많은 사람이 공유할 수 있어야 해서 동시 접근 가능하게 해야 됨
⇒ 이런 요구사항을 만족하며 효율적으로 데이터베이스 관리, 운영함
- 가장 많이 사용하는 DBMS는 관계형
- MySQL, 오라클 등

## 관계형 DBMS

- relational database management system(RDBS)
- 관계형 모델을 기반으로 관리
- 즉, 테이블 형태로 이루어진 데이터 저장소 이용
- 회원 테이블이 있을 때 각 행은 다음과 같은 값을 가지고 있음
    - 속성(열)
        - 고유의 키(아이디)
        - 이메일
        - 나이
- H2
    - 자바로 작성되어 있는 RDBS
    - 스프링부트가 지원하는 인메모리 관계형 데이터베이스(즉, 애플리케이션 자체 내부에 데이터 저장)
    - 실제 서비스에는 잘 사용하지 않지만 개발 시 테스트용으로 많이 사용함

### 데이터베이스 용어

- 테이블
    - 데이터베이스에서 데이터를 구성하기 위한 가장 기본적인 단위
    - 행과 열로 이루어져있음
- 행
    - 테이블의 가로로 배열된 데이터의 집합
    - 행은 반드시 고유한 식별자를 가짐
    - 레코드라고 부르기도 함
- 열
    - 행에 저장되는 유형의 데이터
    - 즉, 각 요소에 대한 속성을 나타냄
    - 무결성 보장
- 기본키
    - 행을 구분할 수 있는 식별자
    - 테이블에서 유일해야 되며, 중복 값을 가질 수 없음
    - 데이터를 수정, 삭제, 조회할 때 사용됨
    - 다른 테이블과 관계를 맺어 데이터 가져옴
    - NULL이 될 수 없고, 값 수정 불가
- 쿼리
    - 데이터를 조회하거나 삭제, 생성, 수정 같은 처리를 하기 위해 사용하는 명령문
    - SQL이라는 전용 언어를 사용하여 작성

## ORM이란?

- 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법
- 데이터베이스의 값을 마치 객체처럼 사용할 수 있음
- SQL은 몰라도 자바 언어로 데이터베이스에 접근해 데이터 다룰 수 있음

### 장점

- 객체지향적으로 코드만 작성 가능하여 비즈니스 로직에만 집중할 수 있음
- 데이터베이스 시스템이 추상화되어 있기 때문에 MySQL에서 PostgreSQL로 전환한다해도 추가도 드는 작업이 거의 없음
- 매핑하는 정보가 명확하여 ERD에 대한 의존도를 낮출 수 있고 유지보수할 때 유리함

## JPA와 하이버네이트

### JPA

- 자바에서 ORM 표준으로 사용
- 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
⇒ 인터페이스여서 실제 사용하기 위해서는 ORM 프레임워크를 추가로 선택해야됨
- 자바 객체와 데이터베이스 연결해 데이터 관리
- 객체 지향 도메인 모델과 데이터베이스의 다리 역할

### 하이버네이트

- 대표적인 ORM 프레임워크
- 내부적으로 JDBC API 사용
- 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하는 것이 목표
- JPA의 인터페이스 구현

## 엔티티 매니저란?

### 엔티티

- 데이터베이스의 테이블과 매핑되는 객체
- 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체

### 엔티티 매니저

- 엔티티를 관리하는 역할
⇒ 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할
- 엔티티 매니저를 만드는 곳이 엔티티 매니저 팩토리
- 스프링 내부에선 엔티티 매니저 팩토리 하나만 생성해서 관리
- @PersistenceContext, @Autowired 애너테이션을 사용하여 엔티티 매니저 사용 
⇒ `@PersistenceContext EntityManager em;`
- 스프링 부트에선 기본적으로 빈을 하나만 생성해서 공유하므로 동시성 문제가 발생할 수도 있음
⇒ 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시 엔티티 매니저 사용
⇒ 필요할 때 데이터베이스 트랜잭션과 관련된 실제 엔티티 매니저를 호출

## 영속성 컨텍스트란?

- JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간
- 영속성 컨텍스트 특징
    - 1차 캐시
        - 캐시의 키: 엔티티의 @Id 애너테이션이 달린 기본키 역할을 하는 식별자
        - 엔티티 조회 시 1차 캐시에 있으면 반환 없으면 데이터베이스에서 조회해 1차 캐시에 저장 후 반환
        ⇒ 캐시된 데이터를 조회할 때에는 데이터베이스를 거치치 않아 매우 빠르게 조회할 수 있음
    - 쓰기 지연
        - 트랜잭션을 커밋하기 전까지 데이터베이스에 실제로 질의문을 보내지 않고 퀴리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행
        - ex) 데이터 추가 쿼리가 3개일 때, 
        영속성 컨텍스트는 트랜잭션을 커밋하는 시점에 3개의 쿼리를 한꺼번에 전송
        - 적당한 묶음의 쿼리를 전송할 수 있어 시스템 부담을 줄일 수 있음
    - 변경 감지
        - 트랜젝션 커밋 시 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동 반영
        - 적당한 묶음의 쿼리를 전송할 수 있어 시스템 부담을 줄일 수 있음
    - 지연 로딩
        - 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것
    
    ⇒ 데이터베이스의 접근을 최소화해 성능을 높일 수 있게 도와줌
    

## 엔티티의 상태

- 분리 상태
    - 영속성 컨텍스트가 관리X
- 관리 상태
    - 영속성 컨텍스트가 관리O
- 비영속 상태
    - 영속성 컨텍스트와 전혀 관계 없음
- 삭제된 상태
    - 영속성 컨텍스트에서 삭제된 상태

```java
public class EntityManagerTest{
	@Autowired
	EntityManager em;
	
	public void example() {
		// 엔티티 매니저가 엔티티를 관리하지 않은 상태(비영속 상태)
		Member member = new Member(1L, "홍길동");
		
		//엔티티가 관리되는 상태
		em.persist(member);
		//엔티티 객체가 분리된 상태
		em.detach(member);
		//앤티티 객체ㅏ 삭제된 상태
		em.remove(member);
	}
```

## 스프링 데이터와 스프링 데이터 JPA

- 스프링 데이터는 비즈니스 로직에 더 집중할 수 있게 데이터베이스 사용 기능을 클래스 레벨에서 추상화함
- 스프링 데이터에서 제공하는 인터페이스를 통해 스프링 데이터를 사용
⇒ CRUD를 포함한 여러 메서드 포함
⇒ 페이징 처리 기능, 메서드 이름으로 쿼리를 자동으로 빌딩하는 기능 제공

### 스프링 데이터 JPA

- 스프링 데이터의 공통적인 기능에서 JPA의 유용한 기술이 추가된 것
- 리포지터리 역할을 하는 인터페이스를 만들어 데이터베이스의 테이블 조회, 수정, 생성, 삭제 같은 작업을 간단히 할 수 있음
- `public interface MemberRepository extends JpaRepository<Member, Long>{ }`
⇒ JpaRepository 인텊페이스를 우리가 만든 인터페이스에서 상속 받아 사용
⇒ 제네릭에는 관리할 <엔티티 이름, 엔티티 키본키의 타입>을 입력하면 기본 CRUD 메서드 사용 가능

### 스프링 데이터 JPA에서 제공하는 메서드 사용

```java
/* MemberService.java */

@Service
public class MemberService {
    @Autowired
    MemberRepository memberRepository;

    public void test() {
		    //생성
        memberRepository.save(new Member(1L, "A"));
				
				//조회
        Optional<Member> member = memberRepository.findById(1L);
        List<Member> allMembers = memberRepository.findAll();

				//삭제
        memberRepository.deleteById(1L);
    }
}
```

- save() 메서드를 호출해 데이터 객체 저장
    - 전달 인수로 엔티티 Member을 넘기면 반환값으로 저장한 엔티티 반환 가능
- findById() 메서드에 id를 지정해 엔티티 하나 조회
- findByAll() 메서드는 전체 엔티티 조회
- deleteById() 메서드에 id를 지정하면 엔티티 삭제

### 예제 코드

```java
/* Member.java */

@NoArgsConstructor(access= AccessLevel.PROTECTED) // 기본 생성자
@AllArgsConstructor
@Getter
@Entity // 엔티티로 지정
public class Member {
    @Id // id 필드를 기본키로 지정
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 기본키를 자동으로 1씩 증가
    @Column(name = "id", updatable = false)
    private Long id;
    @Column(name = "name", nullable = false) // name이라는 not null 컬럼과 매핑
    private String name;

}
```

- @Entity 애너테이션은 Member 객체를 JPA가 관리하는 엔티티로 지정
    - Member 클래스와 실제 데이터베이스의 테이블을 매핑
    - @Entity 속성 중에 name을 사용하면 name의 값을 가진 테이블 이름과 매핑되고, 테이블 이름을 지정하지 않으면 클래스 이름과 같은 테이블과 매핑
- protected 기본 생성자
    - 엔티티는 반드시 기본 생성자 필요
    - 접근 제어자는 protected이나 public이어야 함
- @Id는 Long 타입의 id 필드를 테이블의 기본키로 지정
- @GeneratedValuesms 기본키의 생성 방식을 결정
    - 기본키가 증가되도록 지정
- @Column은 데이터베이스의 컬럼과 필드를 매핑
<br>
<aside>
💡 사용자(요청) → 리포지토리(조회) → DB → 엔티티 → DB(응답) → 리포지토리(응답) → 사용자

</aside>
